import os
import subprocess
import requests
import json
import re
from typing import List, Dict, Optional, Tuple
from dataclasses import dataclass

@dataclass
class CodeIssue:
    """Represents a code issue found during analysis"""
    file_path: str
    line_number: int
    severity: str  # 'error', 'warning', 'suggestion'
    message: str
    rule: str

class CodeAnalyzer:
    """Analyze code and generate review comments dynamically"""
    
    def __init__(self):
        self.rules = {
            'missing_docstring': {
                'pattern': r'^def\s+\w+\([^)]*\):\s*$',
                'message': 'Consider adding a docstring to document this function.',
                'severity': 'suggestion'
            },
            'hardcoded_strings': {
                'pattern': r'print\([\'"][^\'\"]*[\'\"]\)',
                'message': 'Consider using constants or configuration for hardcoded strings.',
                'severity': 'suggestion'
            },
            'no_main_guard': {
                'pattern': r'^[a-zA-Z_].*\(\)',
                'message': 'Consider using if __name__ == "__main__": guard for script execution.',
                'severity': 'warning'
            },
            'long_lines': {
                'check_length': True,
                'max_length': 120,
                'message': 'Line exceeds recommended length. Consider breaking it up.',
                'severity': 'suggestion'
            }
        }
    
    def analyze_file_content(self, file_path: str, content: str, diff_lines: List[int]) -> List[CodeIssue]:
        """Analyze file content and return issues for changed lines only"""
        issues = []
        lines = content.split('\n')
        
        for line_num in diff_lines:
            if line_num <= 0 or line_num > len(lines):
                continue
                
            line = lines[line_num - 1].strip()
            
            # Check each rule
            for rule_name, rule_config in self.rules.items():
                issue = self._check_rule(file_path, line_num, line, rule_name, rule_config)
                if issue:
                    issues.append(issue)
        
        return issues
    
    def _check_rule(self, file_path: str, line_num: int, line: str, rule_name: str, config: Dict) -> Optional[CodeIssue]:
        """Check a single rule against a line"""
        
        # Check line length rule
        if rule_name == 'long_lines' and config.get('check_length'):
            if len(line) > config['max_length']:
                return CodeIssue(
                    file_path=file_path,
                    line_number=line_num,
                    severity=config['severity'],
                    message=config['message'],
                    rule=rule_name
                )
        
        # Check pattern-based rules
        elif 'pattern' in config:
            if re.search(config['pattern'], line):
                return CodeIssue(
                    file_path=file_path,
                    line_number=line_num,
                    severity=config['severity'],
                    message=config['message'],
                    rule=rule_name
                )
        
        return None

class DiffExtractor:
    """Extract diffs and identify changed lines"""
    
    @staticmethod
    def extract_pr_changes(base_branch: str = "origin/main") -> Dict[str, Dict]:
        """Extract PR changes and return file data with changed lines"""
        script_name = os.path.basename(__file__)
        
        # Get diff
        diff_cmd = [
            "git", "diff", f"{base_branch}...HEAD", 
            "--", "*.py", f":(exclude){script_name}"
        ]
        
        try:
            result = subprocess.run(diff_cmd, capture_output=True, text=True, check=True)
            diff_output = result.stdout.strip()
        except subprocess.CalledProcessError as e:
            print(f"Git diff failed: {e}")
            return {}
        
        return DiffExtractor._parse_diff_output(diff_output)
    
    @staticmethod
    def _parse_diff_output(diff_output: str) -> Dict[str, Dict]:
        """Parse git diff output and extract file changes with line numbers"""
        files = {}
        current_file = None
        
        for line in diff_output.splitlines():
            if line.startswith("diff --git"):
                # Extract filename
                parts = line.split()
                if len(parts) >= 4 and parts[3].startswith("b/"):
                    current_file = parts[3][2:]  # Remove "b/" prefix
                    files[current_file] = {
                        'changed_lines': [],
                        'content': None
                    }
            
            elif line.startswith("@@") and current_file:
                # Extract line numbers from hunk header
                # Format: @@ -old_start,old_count +new_start,new_count @@
                match = re.search(r'\+(\d+),?(\d+)?', line)
                if match:
                    start_line = int(match.group(1))
                    count = int(match.group(2)) if match.group(2) else 1
                    
                    # Add changed line numbers
                    for i in range(start_line, start_line + count):
                        if i not in files[current_file]['changed_lines']:
                            files[current_file]['changed_lines'].append(i)
            
            elif line.startswith("+") and not line.startswith("+++") and current_file:
                # Track added lines (actual changes)
                continue
        
        # Get current file contents
        for file_path in files.keys():
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    files[file_path]['content'] = f.read()
            except FileNotFoundError:
                print(f"Warning: File {file_path} not found")
                files[file_path]['content'] = ""
        
        return files

class GitHubCommenter:
    """Post comments to GitHub PR"""
    
    def __init__(self, token: str, repo_owner: str, repo_name: str):
        self.token = token
        self.repo_owner = repo_owner
        self.repo_name = repo_name
        self.headers = {
            'Authorization': f'token {token}',
            'Accept': 'application/vnd.github.v3+json',
            'Content-Type': 'application/json'
        }
        self.base_url = f'https://api.github.com/repos/{repo_owner}/{repo_name}'
    
    def post_review_comments(self, pr_number: int, issues: List[CodeIssue]) -> Dict:
        """Post all review comments to PR"""
        if not issues:
            print("No issues found to comment on.")
            return {"posted": 0, "errors": 0}
        
        # Get PR commit SHA
        pr_response = requests.get(f'{self.base_url}/pulls/{pr_number}', headers=self.headers)
        pr_response.raise_for_status()
        commit_sha = pr_response.json()['head']['sha']
        
        posted_count = 0
        error_count = 0
        
        print(f"Posting {len(issues)} code review comments...")
        
        for issue in issues:
            try:
                payload = {
                    'body': f"**{issue.severity.upper()}**: {issue.message}",
                    'commit_id': commit_sha,
                    'path': issue.file_path,
                    'line': issue.line_number
                }
                
                response = requests.post(
                    f'{self.base_url}/pulls/{pr_number}/comments',
                    headers=self.headers,
                    json=payload
                )
                
                if response.status_code == 201:
                    print(f"‚úì Posted comment on {issue.file_path}:{issue.line_number}")
                    posted_count += 1
                else:
                    print(f"‚úó Failed to post comment on {issue.file_path}:{issue.line_number}: {response.status_code}")
                    error_count += 1
                    
            except Exception as e:
                print(f"‚úó Error posting comment: {e}")
                error_count += 1
        
        # Post summary review
        self._post_summary_review(pr_number, issues, posted_count, error_count)
        
        return {"posted": posted_count, "errors": error_count}
    
    def _post_summary_review(self, pr_number: int, issues: List[CodeIssue], posted: int, errors: int):
        """Post a summary review"""
        
        # Categorize issues
        by_severity = {}
        for issue in issues:
            if issue.severity not in by_severity:
                by_severity[issue.severity] = []
            by_severity[issue.severity].append(issue)
        
        summary = f"""## Automated Code Review Summary

**Comments Posted**: {posted} / {len(issues)}

### Issues Found by Severity:
"""
        
        for severity, severity_issues in by_severity.items():
            summary += f"- **{severity.upper()}**: {len(severity_issues)} issues\n"
        
        summary += f"""
### Files Reviewed:
"""
        
        files_reviewed = list(set(issue.file_path for issue in issues))
        for file_path in files_reviewed:
            file_issues = [i for i in issues if i.file_path == file_path]
            summary += f"- `{file_path}`: {len(file_issues)} issues\n"
        
        summary += "\n*Generated by automated code review pipeline*"
        
        payload = {
            'body': summary,
            'event': 'COMMENT'
        }
        
        try:
            requests.post(f'{self.base_url}/pulls/{pr_number}/reviews', 
                         headers=self.headers, json=payload)
            print("‚úì Posted summary review")
        except Exception as e:
            print(f"‚úó Failed to post summary: {e}")

def main():
    """Main pipeline function"""
    
    # Configuration
    config = {
        'github_token': os.getenv('GITHUB_TOKEN'),
        'repo_owner': 'manishaitrivedi-dot',  # Update this
        'repo_name': 'pr-diff-demo1',         # Update this  
        'pr_number': 3,  # Update this or set env var
        'base_branch': 'origin/main'
    }
    
    if not config['github_token']:
        print("Error: GITHUB_TOKEN environment variable required")
        return
    
    print("üîç Starting dynamic PR code review pipeline...")
    
    # Step 1: Extract changes from PR
    print("1. Extracting PR changes...")
    diff_extractor = DiffExtractor()
    file_changes = diff_extractor.extract_pr_changes(config['base_branch'])
    
    if not file_changes:
        print("No Python file changes found.")
        return
    
    print(f"Found changes in {len(file_changes)} files")
    
    # Step 2: Analyze code and generate issues
    print("2. Analyzing code for issues...")
    analyzer = CodeAnalyzer()
    all_issues = []
    
    for file_path, file_data in file_changes.items():
        if file_data['content'] and file_data['changed_lines']:
            issues = analyzer.analyze_file_content(
                file_path, 
                file_data['content'], 
                file_data['changed_lines']
            )
            all_issues.extend(issues)
            print(f"  - {file_path}: {len(issues)} issues found")
    
    if not all_issues:
        print("No issues found in the changed code.")
        return
    
    # Step 3: Post comments to GitHub
    print("3. Posting comments to GitHub...")
    commenter = GitHubCommenter(
        config['github_token'],
        config['repo_owner'],
        config['repo_name']
    )
    
    results = commenter.post_review_comments(config['pr_number'], all_issues)
    
    print(f"\nüéâ Pipeline completed!")
    print(f"‚úì Posted: {results['posted']} comments")
    print(f"‚úó Errors: {results['errors']} comments")

if __name__ == "__main__":
    main()
